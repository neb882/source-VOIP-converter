<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>TF2 Voice Emulator â€” Authentic</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <style>
    :root {
      --bg: #1b2838;
      --card: #171a21;
      --text: #c5d5e6;
      --accent: #66c0f4;
      --warn: #ff4040;
      --btn-bg: #2a475e;
      --border: #3e4853;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0; padding: 20px;
      min-height: 100vh;
      background: var(--bg); color: var(--text);
      display: flex; justify-content: center; align-items: flex-start;
    }

    .card {
      width: 100%; max-width: 900px;
      background: var(--card);
      border-radius: 8px; padding: 25px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.5);
      border: 1px solid #000;
    }
    
    h1 { margin: 0 0 10px; font-size: clamp(20px, 5vw, 24px); font-weight: 300; letter-spacing: 1px; color: #fff; text-transform: uppercase; text-align: center; }
    p { margin: 0 0 20px; font-size: 14px; color: #8f98a0; line-height: 1.5; text-align: center; }
    
    /* Upload Section */
    .upload-row {
      background: rgba(0,0,0,0.2); padding: 15px; border-radius: 6px;
      display: flex; gap: 10px; align-items: center; margin-bottom: 20px;
      border: 1px solid var(--border); flex-wrap: wrap;
    }

    input[type="file"] { flex-grow: 1; min-width: 200px; color: #ccc; font-size: 13px; }
    input[type="file"]::file-selector-button {
      background: var(--btn-bg); border: none; color: white;
      padding: 8px 12px; border-radius: 4px; cursor: pointer; margin-right: 10px;
    }

    /* Buttons */
    button, .button {
      background: linear-gradient(to bottom, #a4d007 5%, #536904 95%);
      border: none; color: #fff; padding: 12px 20px; border-radius: 4px;
      cursor: pointer; text-decoration: none; font-size: 14px; font-weight: bold;
      text-align: center; box-shadow: 0 2px 5px rgba(0,0,0,0.4);
      white-space: nowrap; flex-grow: 1; transition: transform 0.1s;
    }
    button:active, .button:active { transform: translateY(1px); }
    button:disabled, .button[disabled] { background: #3d4450; color: #707984; cursor: not-allowed; pointer-events: none; box-shadow: none; }

    /* Presets */
    .preset-row { display: flex; gap: 8px; margin-bottom: 20px; align-items: center; flex-wrap: wrap; justify-content: center; }
    .preset-label { font-size: 12px; color: #888; width: 100%; text-align: center; margin-bottom: 4px; }
    .preset-btn { background: var(--btn-bg); font-weight: normal; font-size: 13px; padding: 8px 16px; flex-grow: 1; }

    /* Controls */
    .controls { display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 12px; margin-bottom: 20px; }
    .control { background: rgba(62, 76, 92, 0.2); padding: 12px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.05); }
    
    label { display: block; font-size: 11px; font-weight: bold; color: var(--accent); margin-bottom: 8px; text-transform: uppercase; }
    
    input[type=number], input[type=range], select {
      width: 100%; background: #0e1218; border: 1px solid #3e4853; color: white;
      padding: 8px; border-radius: 4px; font-size: 14px;
    }
    select { cursor: pointer; }
    input[type=range] { -webkit-appearance: none; height: 6px; background: #111; border: none; margin-top: 5px; padding: 0; }
    input[type=range]::-webkit-slider-thumb {
      -webkit-appearance: none; width: 18px; height: 18px;
      background: #888; cursor: pointer; border-radius: 50%; border: 2px solid #ccc;
    }

    /* Custom Reverb Panel */
    #custom-env {
      grid-column: 1 / -1; /* Spans full width */
      display: none;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid var(--accent);
    }
    .custom-row { display: flex; gap: 15px; flex-wrap: wrap; }
    .custom-col { flex: 1; min-width: 100px; }

    /* Visualizer Wrapper */
    .viz-container {
      position: relative;
      width: 100%; height: 120px;
      background: #000;
      border-radius: 6px;
      border: 1px solid #444;
      overflow: hidden;
      margin-top: 15px;
      box-shadow: inset 0 0 20px rgba(0,0,0,0.8);
    }
    
    canvas { width: 100%; height: 100%; display: block; }

    /* CRT Scanline Effect overlay */
    .scanlines {
      position: absolute; top: 0; left: 0; right: 0; bottom: 0;
      background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
      background-size: 100% 4px;
      pointer-events: none;
      z-index: 2;
      opacity: 0.6;
    }
    
    audio { width: 100%; margin-top: 15px; height: 40px; filter: invert(0.9) hue-rotate(180deg); }
    
    .log {
      font-family: "Courier New", monospace; font-size: 12px; color: #67c1f5;
      margin-top: 15px; padding: 10px; background: rgba(0,0,0,0.3);
      border-radius: 4px; border-left: 3px solid var(--accent);
    }
    
    footer { margin-top: 25px; font-size: 11px; color: #555; border-top: 1px solid #333; padding-top: 15px; text-align: center; }

    @media (max-width: 600px) {
      body { padding: 10px; }
      .card { padding: 15px; }
      .upload-row { flex-direction: column; align-items: stretch; }
      .upload-row > * { width: 100%; margin-bottom: 5px; }
      .controls { grid-template-columns: 1fr 1fr; }
    }
  </style>
</head>
<body>

  <div class="card">
    <h1>TF2 Voice Emulator</h1>
    <p>Source Engine Processing &amp; Artifacts</p>

    <div class="upload-row">
      <input id="file" type="file" accept="audio/*">
      <button id="process" disabled>Process Audio</button>
      <a id="download" class="button" download disabled>Download WAV</a>
    </div>

    <div class="preset-row">
      <div class="preset-label">Quick Presets</div>
      <button class="preset-btn" onclick="setPreset('standard')">Authentic (Modern)</button>
      <button class="preset-btn" onclick="setPreset('retro')">Legacy (2007 Era)</button>
      <button class="preset-btn" onclick="setPreset('loud')">Mic Spam (Loud)</button>
    </div>

    <div class="controls">
      <div class="control">
        <label>Rate (Hz)</label>
        <input id="sr" type="number" value="22050" step="50">
      </div>

      <div class="control">
        <label>Mic Gain</label>
        <input id="gain" type="number" value="1.2" min="1.0" max="20.0" step="0.1">
      </div>

      <div class="control">
        <label>Hi-Pass (Hz)</label>
        <input id="hp" type="number" value="300" min="0" max="1000">
      </div>

      <div class="control">
        <label>Lo-Pass (Hz)</label>
        <input id="lp" type="number" value="6000" min="1000" max="20000">
      </div>

      <div class="control">
        <label>Environment</label>
        <select id="env">
          <option value="none">None (Dry)</option>
          <option value="room">Generic Room</option>
          <option value="locker">Locker Room</option>
          <option value="hall">Empty Hallway</option>
          <option value="custom">Custom Params</option>
        </select>
      </div>

      <!-- Custom Reverb Controls (Hidden by default) -->
      <div id="custom-env" class="control">
        <label style="margin-bottom:12px; border-bottom:1px solid #444; padding-bottom:4px;">Custom Reverb Settings</label>
        <div class="custom-row">
          <div class="custom-col">
             <label>Time (sec)</label>
             <input id="c_dur" type="number" value="1.5" step="0.1" min="0.1" max="5.0">
          </div>
          <div class="custom-col">
             <label>Decay Exp</label>
             <input id="c_dec" type="number" value="3.0" step="0.1" min="0.1" max="15.0">
          </div>
          <div class="custom-col">
             <label>Wet Mix %</label>
             <input id="c_mix" type="number" value="25" min="0" max="100">
          </div>
        </div>
      </div>

      <div class="control">
        <label>Bit Depth</label>
        <input id="bits" type="number" value="16" min="4" max="16">
      </div>

      <div class="control">
        <label>Packet (ms)</label>
        <input id="frameMs" type="number" value="20" min="10" max="100">
      </div>

      <div class="control">
        <label>Loss %</label>
        <input id="loss" type="number" value="0" min="0" max="40">
      </div>
    </div>

    <div class="viz-container">
      <div class="scanlines"></div>
      <canvas id="visualizer"></canvas>
    </div>

    <audio id="preview" controls crossorigin="anonymous"></audio>
    <div id="log" class="log">System Ready. Upload a file to begin.</div>

    <footer>
      Local Browser Processing | Emulates Steam Voice / CELT Codec Artifacts
    </footer>
  </div>

<script>
/* --- CONFIG & STATE --- */
const presets = {
  standard: { sr: 22050, hp: 300, lp: 6000, bits: 16, gain: 1.2, loss: 0, env: 'none' },
  retro:    { sr: 11025, hp: 400, lp: 3500, bits: 8,  gain: 2.5, loss: 0, env: 'room' },
  loud:     { sr: 22050, hp: 200, lp: 12000, bits: 12, gain: 12.0, loss: 0, env: 'none' }
};

const els = {
  file: document.getElementById('file'),
  process: document.getElementById('process'),
  dl: document.getElementById('download'),
  audio: document.getElementById('preview'),
  log: document.getElementById('log'),
  canvas: document.getElementById('visualizer'),
  gain: document.getElementById('gain'),
  env: document.getElementById('env'),
  customEnv: document.getElementById('custom-env')
};

// Reverb configurations: [duration(sec), decay, mix(0-1)]
const envConfigs = {
  none:   null,
  room:   [0.5, 3.0, 0.15],
  locker: [0.3, 8.0, 0.25],
  hall:   [1.5, 4.0, 0.35]
};

let state = {
  lastBlob: null,
  processedBuffer: null, // Float32Array of whole file
  audioCtx: null,
  analyser: null,
  sourceNode: null,
  isPlaying: false,
  animationId: null
};

/* --- UI HANDLERS --- */
els.env.addEventListener('change', () => {
  const isCustom = els.env.value === 'custom';
  els.customEnv.style.display = isCustom ? 'block' : 'none';
});

function setPreset(name){
  const p = presets[name];
  document.getElementById('sr').value = p.sr;
  document.getElementById('hp').value = p.hp;
  document.getElementById('lp').value = p.lp;
  document.getElementById('bits').value = p.bits;
  document.getElementById('gain').value = p.gain;
  document.getElementById('loss').value = p.loss;
  
  els.env.value = p.env;
  // Trigger change event manually to update visibility
  els.env.dispatchEvent(new Event('change'));
  
  writeLog(`Loaded preset: ${name.toUpperCase()}`);
}

els.file.addEventListener('change', () => {
  els.process.disabled = !els.file.files.length;
  if(els.file.files.length) writeLog("File selected: " + els.file.files[0].name);
});

function writeLog(s){ els.log.textContent = "> " + s; }

/* --- VISUALIZER ENGINE --- */
const ctx = els.canvas.getContext('2d');

function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1;
  const rect = els.canvas.getBoundingClientRect();
  els.canvas.width = rect.width * dpr;
  els.canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  return { w: rect.width, h: rect.height };
}

// Mode 1: Static Waveform (Whole File)
function drawStaticWaveform() {
  if(!state.processedBuffer) return;
  const { w, h } = resizeCanvas();
  const data = state.processedBuffer;
  
  ctx.clearRect(0, 0, w, h);
  
  // Draw Grid
  drawGrid(w, h);

  ctx.fillStyle = '#66c0f4'; // TF2 Blue
  const step = Math.ceil(data.length / w);
  const amp = h / 2;

  ctx.beginPath();
  for(let i = 0; i < w; i++){
    let min = 1.0, max = -1.0;
    for(let j=0; j<step; j++){
      const val = data[(i*step)+j];
      if(val < min) min = val;
      if(val > max) max = val;
    }
    if(max < min) { min=0; max=0; }
    
    const yTop = (1 - max) * amp;
    const yBot = (1 - min) * amp;
    ctx.fillRect(i, yTop, 1, Math.max(1, yBot - yTop));
  }
}

// Mode 2: Live Spectrum (Animated)
function animateSpectrum() {
  if(!state.isPlaying) return;
  
  const { w, h } = resizeCanvas();
  const bufferLength = state.analyser.frequencyBinCount;
  const dataArray = new Uint8Array(bufferLength);
  state.analyser.getByteFrequencyData(dataArray);
  
  ctx.clearRect(0, 0, w, h);
  drawGrid(w, h);

  const barWidth = (w / bufferLength) * 2.5;
  let barHeight;
  let x = 0;
  
  // Detect Volume for Color Shift (Red if loud)
  let sum = 0;
  for(let i=0; i<bufferLength; i++) sum += dataArray[i];
  const avg = sum / bufferLength;
  const isLoud = avg > 60; // Threshold
  
  for(let i = 0; i < bufferLength; i++) {
    barHeight = (dataArray[i] / 255) * h;
    
    // Dynamic Color
    if(isLoud && barHeight > h*0.6) {
      ctx.fillStyle = `rgb(${barHeight + 100}, 50, 50)`; // Red glow
    } else {
      ctx.fillStyle = `rgb(${50}, ${barHeight + 100}, 240)`; // Blue glow
    }
    
    // Draw Bar
    ctx.fillRect(x, h - barHeight, barWidth, barHeight);
    
    // Reflection (Glassy effect)
    ctx.fillStyle = 'rgba(255,255,255,0.1)';
    ctx.fillRect(x, h - barHeight, barWidth, 2);

    x += barWidth + 1;
  }
  
  state.animationId = requestAnimationFrame(animateSpectrum);
}

function drawGrid(w, h) {
  ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
  ctx.lineWidth = 1;
  // Horiz lines
  ctx.beginPath();
  ctx.moveTo(0, h/2); ctx.lineTo(w, h/2);
  ctx.moveTo(0, h/4); ctx.lineTo(w, h/4);
  ctx.moveTo(0, h*0.75); ctx.lineTo(w, h*0.75);
  ctx.stroke();
}

/* --- AUDIO HANDLING --- */
els.audio.addEventListener('play', () => {
  if(!state.audioCtx) initAudioContext();
  if(state.audioCtx.state === 'suspended') state.audioCtx.resume();
  state.isPlaying = true;
  cancelAnimationFrame(state.animationId);
  animateSpectrum();
});

els.audio.addEventListener('pause', () => {
  state.isPlaying = false;
  cancelAnimationFrame(state.animationId);
  drawStaticWaveform(); // Revert to static view
});

els.audio.addEventListener('ended', () => {
  state.isPlaying = false;
  cancelAnimationFrame(state.animationId);
  drawStaticWaveform();
});

function initAudioContext() {
  // Set up the live analyser for the <audio> tag
  state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  state.analyser = state.audioCtx.createAnalyser();
  state.analyser.fftSize = 256;
  // Connect DOM audio element to Analyser -> Speaker
  state.sourceNode = state.audioCtx.createMediaElementSource(els.audio);
  state.sourceNode.connect(state.analyser);
  state.analyser.connect(state.audioCtx.destination);
}

/* --- DSP PROCESSING CHAIN --- */
els.process.addEventListener('click', async () => {
  els.process.disabled = true; els.dl.setAttribute('disabled', 'true');
  writeLog("Processing started...");

  try {
    const file = els.file.files[0];
    const arrayBuffer = await file.arrayBuffer();
    const tempCtx = new (window.AudioContext || window.webkitAudioContext)();
    const decoded = await tempCtx.decodeAudioData(arrayBuffer);
    
    // Mixdown to Mono
    const monoRaw = new Float32Array(decoded.length);
    if (decoded.numberOfChannels === 1) {
      monoRaw.set(decoded.getChannelData(0));
    } else {
      const ch0 = decoded.getChannelData(0);
      const ch1 = decoded.getChannelData(1);
      for(let i=0; i<decoded.length; i++) monoRaw[i] = (ch0[i] + ch1[i]) / 2;
    }

    // Setup Offline Render
    const targetRate = parseInt(document.getElementById('sr').value);
    const envChoice = els.env.value;
    
    // Determine Reverb Params
    let revDur = 0, revDecay = 0, revMix = 0;
    
    if (envChoice === 'custom') {
      revDur = Number(document.getElementById('c_dur').value);
      revDecay = Number(document.getElementById('c_dec').value);
      revMix = Number(document.getElementById('c_mix').value) / 100;
    } else if (envConfigs[envChoice]) {
      [revDur, revDecay, revMix] = envConfigs[envChoice];
    }

    // Calculate tail based on duration
    const extraTail = (revMix > 0) ? revDur * targetRate : 0;
    
    const offline = new OfflineAudioContext(1, Math.ceil(decoded.duration * targetRate) + extraTail, targetRate);
    
    const src = offline.createBufferSource();
    const buf = offline.createBuffer(1, monoRaw.length, decoded.sampleRate);
    buf.copyToChannel(monoRaw, 0, 0);
    src.buffer = buf;

    // Filters
    const hp = offline.createBiquadFilter();
    hp.type = 'highpass'; hp.frequency.value = Number(document.getElementById('hp').value);
    
    const lp = offline.createBiquadFilter();
    lp.type = 'lowpass'; lp.frequency.value = Number(document.getElementById('lp').value);

    const dist = offline.createWaveShaper();
    const gainVal = Number(document.getElementById('gain').value);
    dist.curve = makeDistortionCurve((gainVal - 1) * 20);

    const comp = offline.createDynamicsCompressor();
    comp.threshold.value = -12;
    comp.ratio.value = 12;
    comp.attack.value = 0.003;
    comp.release.value = 0.25;

    // Build Chain: Src -> HP -> Dist -> LP
    src.connect(hp); hp.connect(dist); dist.connect(lp);

    // Reverb Logic
    if (revMix > 0) {
      const conv = offline.createConvolver();
      conv.buffer = makeImpulse(offline, revDur, revDecay);
      
      const wetGain = offline.createGain();
      wetGain.gain.value = revMix;
      
      const dryGain = offline.createGain();
      dryGain.gain.value = 1.0; 
      
      // Split path
      lp.connect(dryGain);
      dryGain.connect(comp);
      
      lp.connect(conv);
      conv.connect(wetGain);
      wetGain.connect(comp);
      
    } else {
      // Direct path
      lp.connect(comp);
    }

    comp.connect(offline.destination);

    src.start(0);
    const rendered = await offline.startRendering();
    let samples = rendered.getChannelData(0);

    // Artifacts: Bitcrush & Packet Loss
    const bits = Number(document.getElementById('bits').value);
    const loss = Number(document.getElementById('loss').value);
    const frameMs = Number(document.getElementById('frameMs').value);
    
    samples = quantize(samples, bits);
    samples = applyPacketLoss(samples, targetRate, frameMs, loss);

    // Store for Static Draw
    state.processedBuffer = samples;
    
    // Encode & Output
    const wavBlob = makeWav(samples, targetRate);
    if(state.lastBlob) URL.revokeObjectURL(state.lastBlob);
    state.lastBlob = URL.createObjectURL(wavBlob);
    
    els.audio.src = state.lastBlob;
    els.dl.href = state.lastBlob;
    els.dl.download = file.name.replace(/\.[^/.]+$/, "") + "_tf2.wav";
    els.dl.removeAttribute('disabled');

    // Initial Draw
    drawStaticWaveform();
    writeLog("Done. Press Play.");

  } catch(e) {
    console.error(e);
    writeLog("Error: " + e.message);
  } finally {
    els.process.disabled = false;
  }
});

/* --- UTILS --- */
function makeDistortionCurve(amount) {
  if (amount <= 0) return new Float32Array([0, 0]);
  const k = amount, n = 44100, curve = new Float32Array(n), deg = Math.PI / 180;
  for (let i = 0; i < n; ++i) {
    let x = i * 2 / n - 1;
    // Standard sigmoid distortion
    curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
  }
  return curve;
}

function makeImpulse(ctx, duration, decay) {
  const rate = ctx.sampleRate;
  const len = rate * duration;
  const buffer = ctx.createBuffer(1, len, rate); // Mono impulse
  const data = buffer.getChannelData(0);
  
  for (let i = 0; i < len; i++) {
    // White noise with exponential decay
    const noise = (Math.random() * 2) - 1;
    const env = Math.pow(1 - (i / len), decay);
    data[i] = noise * env;
  }
  return buffer;
}

function quantize(data, bits) {
  if(bits >= 32) return data;
  const step = Math.pow(2, bits);
  for(let i=0; i<data.length; i++) {
    // Simple linear quantization
    data[i] = Math.floor(data[i]*step)/step;
  }
  return data;
}

function applyPacketLoss(data, rate, ms, pct) {
  if(pct <= 0) return data;
  const frameSz = Math.floor(rate * (ms/1000));
  const out = new Float32Array(data.length);
  let last = 0;
  for(let off=0; off<data.length; off+=frameSz) {
    const lost = Math.random()*100 < pct;
    for(let i=0; i<frameSz; i++) {
      if(off+i >= data.length) break;
      if(lost) out[off+i] = last; // Hold last sample (Robotic artifact)
      else { out[off+i] = data[off+i]; last = data[off+i]; }
    }
  }
  return out;
}

function makeWav(data, rate) {
  const buf = new ArrayBuffer(44 + data.length*2);
  const view = new DataView(buf);
  const writeStr = (o, s) => { for(let i=0;i<s.length;i++) view.setUint8(o+i, s.charCodeAt(i)); };
  
  writeStr(0, 'RIFF'); view.setUint32(4, 36+data.length*2, true); writeStr(8, 'WAVE');
  writeStr(12, 'fmt '); view.setUint32(16, 16, true); view.setUint16(20, 1, true);
  view.setUint16(22, 1, true); view.setUint32(24, rate, true); view.setUint32(28, rate*2, true);
  view.setUint16(32, 2, true); view.setUint16(34, 16, true); writeStr(36, 'data');
  view.setUint32(40, data.length*2, true);

  let offset = 44;
  for(let i=0; i<data.length; i++, offset+=2) {
    let s = Math.max(-1, Math.min(1, data[i]));
    view.setInt16(offset, s<0 ? s*0x8000 : s*0x7FFF, true);
  }
  return new Blob([buf], {type:'audio/wav'});
}

window.addEventListener('resize', () => {
  if(state.isPlaying) return; // Animation loop handles resize automatically
  drawStaticWaveform();
});
</script>
</body>
</html>


