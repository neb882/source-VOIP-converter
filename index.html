<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TF2 CELT Emulator — single-file</title>
  <style>
    :root{font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:0;color:#111}
    body{display:flex;min-height:100vh;align-items:center;justify-content:center;background:#0f1724;color:#e6eef8}
    .card{width:880px;max-width:95%;background:linear-gradient(180deg,#0b1220 0%, #071026 100%);border-radius:12px;padding:20px;box-shadow:0 10px 30px rgba(2,6,23,.6)}
    h1{margin:0 0 8px;font-size:20px}
    p{margin:0 0 12px;color:#a9c0df}
    .row{display:flex;gap:12px;align-items:center}
    label{font-size:13px;color:#cfe0ff}
    input[type=file]{display:block}
    .controls{display:grid;grid-template-columns:repeat(2,1fr);gap:10px;margin-top:12px}
    .control{background:rgba(255,255,255,0.02);padding:10px;border-radius:8px}
    button, a.button{background:#1f6feb;border:none;color:white;padding:10px 14px;border-radius:8px;cursor:pointer;text-decoration:none;text-align:center;display:inline-block}
    button:disabled, a.button[disabled]{opacity:.45;pointer-events:none}
    audio{width:100%;margin-top:12px}
    .small{font-size:12px;color:#93b8ea}
    .note{margin-top:10px;font-size:12px;color:#9fbbe2}
    .params{display:flex;gap:6px;flex-wrap:wrap}
    .param{display:flex;flex-direction:column}
    footer{margin-top:12px;font-size:12px;color:#7ea6df}
    .link{color:#9fd0ff}
  </style>
</head>
<body>
  <div class="card">
    <h1>TF2 CELT Emulator</h1>
    <p>Upload an MP3 (or other audio). This page resamples to TF2/Steam-voice‑style settings, applies lowpass/bitcrush/packet-like artifacts, and produces a downloadable WAV you can play to emulate TF2 voice chat.</p>

    <div class="row">
      <input id="file" type="file" accept="audio/*">
      <button id="process" disabled>Convert &amp; Emulate</button>
      <a id="download" class="button" download disabled>Download WAV</a>
    </div>

    <div class="controls" style="margin-top:14px">
      <div class="control">
        <label>Target sample rate (Hz)</label>
        <div class="params">
          <div class="param"><input id="sr" type="number" value="14000" min="8000" max="48000"><span class="small">24000 is commonly used for Steam voice.</span></div>
        </div>
      </div>

      <div class="control">
        <label>Lowpass cutoff (Hz)</label>
        <div class="params">
          <div class="param"><input id="lp" type="number" value="10000" min="1000" max="20000"></div>
        </div>
      </div>

      <div class="control">
        <label>Bit depth emulation (bits)</label>
        <div class="params">
          <div class="param"><input id="bits" type="number" value="12" min="4" max="16"></div>
        </div>
      </div>

      <div class="control">
        <label>Frame size (ms) — packet effect</label>
        <div class="params">
          <div class="param"><input id="frameMs" type="number" value="20" min="5" max="100"></div>
        </div>
      </div>

      <div class="control">
        <label>Packet loss simulation (%)</label>
        <div class="params">
          <div class="param"><input id="loss" type="number" value="0" min="0" max="50"></div>
        </div>
      </div>

      <div class="control">
        <label>Hold-down factor (downsampling) — bigger = chunkier</label>
        <div class="params">
          <div class="param"><input id="hold" type="number" value="1" min="1" max="10"></div>
        </div>
      </div>

    </div>

    <audio id="preview" controls></audio>
    <div id="log" class="note"></div>
    <footer>Note: This is an <strong>emulation</strong> of CELT/Steam-voice artifacts (resampling, lowpass, bit-depth quantization, packetization). It does <em>not</em> actually encode to CELT. For background: TF2 switched to CELT as its default voice codec; Steam/Valve voice commonly uses 24000 Hz mono linear expectations.</footer>
  </div>

<script>
(async function(){
  const fileIn = document.getElementById('file');
  const processBtn = document.getElementById('process');
  const downloadBtn = document.getElementById('download');
  const preview = document.getElementById('preview');
  const log = document.getElementById('log');

  let lastBlobUrl = null;

  fileIn.addEventListener('change', () => {
    processBtn.disabled = !fileIn.files.length;
  });

  function writeLog(s){ log.textContent = s; }

  function floatTo16BitPCM(float32Array){
    const buffer = new ArrayBuffer(float32Array.length * 2);
    const view = new DataView(buffer);
    let offset = 0;
    for (let i = 0; i < float32Array.length; i++, offset += 2){
      let s = Math.max(-1, Math.min(1, float32Array[i]));
      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
    }
    return buffer;
  }

  function makeWav(float32Array, sampleRate){
    const wavBuffer = new ArrayBuffer(44 + float32Array.length * 2);
    const view = new DataView(wavBuffer);
    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + float32Array.length * 2, true);
    writeString(view, 8, 'WAVE');
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true);
    view.setUint16(22, 1, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, sampleRate * 2, true);
    view.setUint16(32, 2, true);
    view.setUint16(34, 16, true);
    writeString(view, 36, 'data');
    view.setUint32(40, float32Array.length * 2, true);
    const pcm = floatTo16BitPCM(float32Array);
    const pcmView = new Uint8Array(pcm);
    const out = new Uint8Array(wavBuffer);
    out.set(pcmView, 44);
    return new Blob([out], { type: 'audio/wav' });
  }

  function writeString(view, offset, string){
    for (let i = 0; i < string.length; i++){
      view.setUint8(offset + i, string.charCodeAt(i));
    }
  }

  function quantizeBits(samples, bits){
    if (bits >= 16) return samples;
    const maxInt = Math.pow(2, bits - 1) - 1;
    for (let i = 0; i < samples.length; i++){
      samples[i] = Math.round(samples[i] * maxInt) / maxInt;
    }
    return samples;
  }

  function applyPacketLossAndHold(samples, sampleRate, frameMs, lossPct, holdFactor){
    const frameSize = Math.max(1, Math.round(sampleRate * (frameMs/1000)));
    for (let offset = 0; offset < samples.length; offset += frameSize){
      if (lossPct > 0 && Math.random() * 100 < lossPct){
        for (let i = 0; i < frameSize && offset + i < samples.length; i++) samples[offset + i] = 0;
        continue;
      }
      if (holdFactor > 1){
        for (let i = 0; i < frameSize && offset + i < samples.length; i++){
          const sourceIndex = offset + Math.floor(i/holdFactor) * holdFactor;
          samples[offset + i] = samples[sourceIndex];
        }
      }
    }
    return samples;
  }

  processBtn.addEventListener('click', async () => {
    processBtn.disabled = true; downloadBtn.setAttribute('disabled', 'true'); writeLog('Starting...');
    try{
      const f = fileIn.files[0];
      const arrayBuffer = await f.arrayBuffer();
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      const decoded = await audioCtx.decodeAudioData(arrayBuffer.slice(0));
      writeLog(`Decoded: ${decoded.numberOfChannels} channels, ${Math.round(decoded.sampleRate)} Hz, ${decoded.length} samples`);

      const len = decoded.length;
      const mono = audioCtx.createBuffer(1, len, decoded.sampleRate);
      const outCh = mono.getChannelData(0);
      for (let c = 0; c < decoded.numberOfChannels; c++){
        const ch = decoded.getChannelData(c);
        for (let i = 0; i < len; i++) outCh[i] = (outCh[i] || 0) + ch[i] / decoded.numberOfChannels;
      }

      const targetRate = Number(document.getElementById('sr').value) || 14000;
      const offline = new OfflineAudioContext(1, Math.ceil(mono.duration * targetRate), targetRate);
      const src = offline.createBufferSource();
      src.buffer = mono;
      const lp = offline.createBiquadFilter(); lp.type = 'lowpass'; lp.frequency.value = Number(document.getElementById('lp').value) || 10000;
      const comp = offline.createDynamicsCompressor();
      src.connect(lp);
      lp.connect(comp);
      comp.connect(offline.destination);
      src.start(0);
      writeLog('Rendering (resample + lowpass + compression)...');
      const rendered = await offline.startRendering();

      let samples = rendered.getChannelData(0).slice(0);
      const bits = Number(document.getElementById('bits').value) || 12;
      samples = quantizeBits(samples, bits);
      const frameMs = Number(document.getElementById('frameMs').value) || 20;
      const loss = Number(document.getElementById('loss').value) || 0;
      const hold = Number(document.getElementById('hold').value) || 1;
      samples = applyPacketLossAndHold(samples, targetRate, frameMs, loss, hold);

      writeLog('Encoding WAV...');
      const wav = makeWav(samples, targetRate);

      if (lastBlobUrl) URL.revokeObjectURL(lastBlobUrl);
      lastBlobUrl = URL.createObjectURL(wav);
      preview.src = lastBlobUrl;
      downloadBtn.href = lastBlobUrl;
      downloadBtn.download = (f.name.replace(/\.[^\.]+$/, '') || 'output') + '_tf2_voip.wav';
      downloadBtn.removeAttribute('disabled');
      writeLog('Done — play preview or download the WAV.');

    } catch (err){
      console.error(err);
      writeLog('Error: ' + (err && err.message ? err.message : err));
    } finally{
      processBtn.disabled = false;
    }
  });
})();
</script>
</body>
</html>
