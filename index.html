<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOIP Audio Effect Simulator (TF2/CS:S with CELT)</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto; padding: 20px; }
        input, button { margin: 10px 0; }
        #status { color: green; }
        #error { color: red; }
    </style>
</head>
<body>
    <h1>VOIP Chat Audio Effect (TF2/CS:S with CELT)</h1>
    <p>Upload an MP3 file, and this tool will process it using the CELT codec to mimic the later Source Engine VOIP sound: resampled to 22kHz mono, encoded/decoded with CELT for authentic compression artifacts (~22kbps). Preview and download as WAV (convert to MP3 if needed).</p>
    
    <input type="file" id="fileInput" accept="audio/mp3">
    <button id="processBtn">Process Audio</button>
    <p id="status"></p>
    <p id="error"></p>
    
    <audio id="preview" controls></audio>
    <a id="downloadLink" style="display: none;">Download Processed Audio (WAV)</a>

    <!-- New: Include the libcelt7.js library (download from https://github.com/Johni0702/libcelt7.js/tree/master/build) -->
    <script src="libcelt7.js"></script>

    <script>
        const fileInput = document.getElementById('fileInput');
        const processBtn = document.getElementById('processBtn');
        const status = document.getElementById('status');
        const error = document.getElementById('error');
        const preview = document.getElementById('preview');
        const downloadLink = document.getElementById('downloadLink');

        processBtn.addEventListener('click', async () => {
            const file = fileInput.files[0];
            if (!file) {
                error.textContent = 'Please select an MP3 file.';
                return;
            }
            status.textContent = 'Processing...';
            error.textContent = '';

            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const arrayBuffer = await file.arrayBuffer();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);

                // New: Target 22kHz for CELT vaudio_celt mode
                const targetSampleRate = 22050;
                const newLength = Math.ceil(audioBuffer.length * targetSampleRate / audioBuffer.sampleRate);
                const offlineCtx = new OfflineAudioContext(1, newLength, targetSampleRate); // Mono, 22kHz

                // Source node with mono buffer
                const source = offlineCtx.createBufferSource();
                source.buffer = toMono(audioBuffer);

                // Connect directly to destination (no filters needed, CELT will add artifacts)
                source.connect(offlineCtx.destination);

                // Render the resampled mono buffer
                source.start();
                const renderedBuffer = await offlineCtx.startRendering();

                // New: Get raw PCM samples as Float32Array
                const samples = renderedBuffer.getChannelData(0);

                // New: Encode to CELT, then decode back to simulate VOIP round-trip artifacts
                const frameSize = 441; // ~20ms at 22kHz (0.02 * 22050 = 441)
                const targetSize = 55; // ~22kbps: (bitrate * frame_ms / 8) / 1000 â‰ˆ 55 bytes per frame
                const enc = new Encoder({ rate: targetSampleRate, frameSize: frameSize, channels: 1 });
                const dec = new Decoder({ rate: targetSampleRate, frameSize: frameSize, channels: 1 });

                const decodedSamples = new Float32Array(samples.length);
                let offset = 0;
                for (let i = 0; i < samples.length; i += frameSize) {
                    const frame = samples.subarray(i, i + frameSize);
                    if (frame.length < frameSize) continue; // Skip incomplete frames at end

                    const encoded = enc.encode(frame, targetSize);
                    const decodedFrame = dec.decodeFloat32(encoded);

                    decodedSamples.set(decodedFrame, offset);
                    offset += decodedFrame.length;
                }

                // New: Create a new AudioBuffer from decoded samples (at 22kHz mono)
                const processedBuffer = offlineCtx.createBuffer(1, offset, targetSampleRate);
                processedBuffer.getChannelData(0).set(decodedSamples.subarray(0, offset));

                // Preview
                const blob = await audioBufferToWav(processedBuffer);
                const url = URL.createObjectURL(blob);
                preview.src = url;
                preview.style.display = 'block';

                // Download link
                downloadLink.href = url;
                downloadLink.download = 'processed_voip_audio.wav';
                downloadLink.textContent = 'Download Processed Audio (WAV)';
                downloadLink.style.display = 'block';

                status.textContent = 'Processing complete! Preview below and download.';
            } catch (err) {
                error.textContent = 'Error processing audio: ' + err.message;
                status.textContent = '';
            }
        });

        // Helper: Convert stereo to mono (unchanged)
        function toMono(buffer) {
            if (buffer.numberOfChannels === 1) return buffer;
            const monoBuffer = new AudioBuffer({
                length: buffer.length,
                numberOfChannels: 1,
                sampleRate: buffer.sampleRate
            });
            const left = buffer.getChannelData(0);
            const right = buffer.getChannelData(1);
            const monoData = monoBuffer.getChannelData(0);
            for (let i = 0; i < buffer.length; i++) {
                monoData[i] = (left[i] + right[i]) / 2;
            }
            return monoBuffer;
        }

        // Helper: Convert AudioBuffer to WAV Blob (unchanged)
        function audioBufferToWav(buffer) {
            return new Promise((resolve) => {
                const numChannels = buffer.numberOfChannels;
                const sampleRate = buffer.sampleRate;
                const length = buffer.length * numChannels * 2 + 44;
                const wavBuffer = new ArrayBuffer(length);
                const view = new DataView(wavBuffer);

                // RIFF chunk
                writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + buffer.length * numChannels * 2, true);
                writeString(view, 8, 'WAVE');
                // FMT sub-chunk
                writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true); // PCM
                view.setUint16(22, numChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * numChannels * 2, true);
                view.setUint16(32, numChannels * 2, true);
                view.setUint16(34, 16, true); // 16-bit
                // Data sub-chunk
                writeString(view, 36, 'data');
                view.setUint32(40, buffer.length * numChannels * 2, true);

                // Write samples
                let offset = 44;
                for (let i = 0; i < buffer.length; i++) {
                    for (let channel = 0; channel < numChannels; channel++) {
                        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                        view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                        offset += 2;
                    }
                }

                resolve(new Blob([wavBuffer], { type: 'audio/wav' }));
            });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
    </script>
</body>
</html>
